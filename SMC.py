import ssl
import json
import urllib.request
import http.cookiejar
import argparse
import sys
import datetime
import socket
from time import sleep

# args, beautiful args
parser = argparse.ArgumentParser()
parser.add_argument('--source', type=str, help='fqdn of source host', required=True)
parser.add_argument('--destination', type=str, help='fqdn of destination host', required=True)
parser.add_argument('--protocol', type=str, choices=['rdp','ssh'], help='Remote asccess protocol of DESTINATION', required=True)
parser.add_argument('--smc', type=str, help='Address of the SMC management server', required=True)
parser.add_argument('--key', type=str, help='API access key for SMCSERVER', required=True)
args = parser.parse_args()

# create ssl context and set to ignore errors generated by self-signed certificates
ssl._create_default_https_context = ssl._create_unverified_context

# global constants
FIREWALL_CLUSTER_NAME = 'fw_cluster'
SMC_BASE_URI = "https://%s:8082/6.2" % args.smc
HEADERS = {"Content-type" : "application/json"}
CJ = http.cookiejar.CookieJar()
OPENER = urllib.request.build_opener(urllib.request.HTTPCookieProcessor(CJ))
IPV4_ACCESS_RULE_TEMPLATE = {"action":{"action":"allow",},"destinations":{"dst":[]},"comment": "","services":{"service":[]},"sources":{"src":[]}}

def query_by_name(name, type='host'):
    try:
        # strip fqdn from name, if it exists
        if type == 'host':
            name = name.split('.')[0]
        
        uri = "%s/elements/%s" % (SMC_BASE_URI, type)
        
        req = urllib.request.Request(url=uri, headers=HEADERS, method='GET')
        with OPENER.open(req) as http_response:
            json_response = json.loads(http_response.read())

        for element in json_response['result']:
            if element['name'] != name:
                found = None 
            else:
                return element

        if found == None:
            return None
        else:
            raise RuntimeError('Unspecified error in host query')

    except Exception as e:
        print("There was a problem querying the SMC for %s: %s" % (name, e))
        sys.exit(1)

def query_by_href(href):
    try:
        req = urllib.request.Request(url=href, headers=HEADERS, method='GET')
        with OPENER.open(req) as http_response:
            json_response = json.loads(http_response.read())
        
        return json_response

    except Exception as e:
        print("Unable to query href with error: %s" % e)
        sys.exit(1)

def add_host(host):
    try:
        ip_address = socket.gethostbyname(host)
        name = host.split('.')[0]

        json = '{"name" : "%s","address" : "%s"}' % (name, ip_address)

        req = urllib.request.Request(url="%s/elements/host" % SMC_BASE_URI, data=json.encode(), headers=HEADERS, method='POST')
        with OPENER.open(req) as http_response:
            pass

        return query_by_name(name)
        
    except Exception as e:
        print("Unable to add %s to the SMC with error: %s" % (host,e))
        sys.exit(1)

def add_to_group(group, host):
    try:
        # get json for group and add the destination host's href to its elements array
        group_json = query_by_href((query_by_name(group,'group'))['href'])
        group_json['element'].append(host['href']) 

        # href for group
        href = group_json['link'][0]['href']

        # get group etag and add to headers
        req = urllib.request.Request(url=href, headers=HEADERS, method='GET')
        with OPENER.open(req) as http_response:
             etagged_headers = HEADERS
             etagged_headers['Etag'] = http_response.getheader('etag')[1:-1]

        # modify group
        req = urllib.request.Request(url=href, data=json.dumps(group_json).encode(), headers=etagged_headers, method='PUT')
        with OPENER.open(req) as http_response:
            if http_response.status == 200:
                pass
            else:
                raise RuntimeError('Unspecified error during group modification') 
            
    except Exception as e:
        print("Unable to modify group with error: %s" % e)
        sys.exit(1)

def main():
    # log into smc
    login = '{"authenticationkey" : "%s"}' % args.key
    req = urllib.request.Request(url="%s/login" % SMC_BASE_URI, data=login.encode(), headers=HEADERS, method='POST')

    try:
        with OPENER.open(req) as http_response:
            pass

    except Exception as e:
        print("Unable to login to the SMC")
        sys.exit(1)

    try:
        # check if destination hosts exists, if not create it, or else get its json 
        d_host = query_by_name(args.destination)

        if d_host is None:
            d_host = add_host(args.destination)

        # check if the source host exists, if not add it, or else get its json
        s_host = query_by_name(args.source)

        if s_host is None:
            s_host = add_host(args.source)
            bastion_access_group = None
        else:
            # check if the host definition has a 'comment' section
            # and if that comment indicates the host is a bastion host
            s_host_info = query_by_href(s_host['href'])

            if 'comment' in s_host_info.keys():
                # if the host is a bastion host, add the destination to its cooresponding group
                if 'bastion' in s_host_info['comment'].lower():
                    bastion_access_group = s_host_info['comment'].split(':')[1].strip() + '-%s-Access' % args.protocol.upper()
                else:
                    bastion_access_group = None
            else:
                bastion_access_group = None
                
        # if the host is not a known bastion host, create a rule for it
        # in the subpolicy that governers its protocol,
        # otherwise add the destination to the bastion hosts access group            
        if bastion_access_group is not None:
            add_to_group(bastion_access_group, d_host)
        else:   
            # get hrefs for ipv4 subpolicies
            policy_href = query_by_name("%s-Access-Policy" % args.protocol.upper(), 'sub_ipv4_fw_policy')['href']

            ipv4_access_rule = IPV4_ACCESS_RULE_TEMPLATE

            # get existing ipv4 access rules for subpolicy
            req = urllib.request.Request(url="%s/fw_ipv4_access_rule" % policy_href, headers=HEADERS, method='GET')
            with OPENER.open(req) as http_response:
                access_rules = json.loads(http_response.read())['result']
            
            # find last access rule so we can add our new rule before it. presumably, the last rule is a REJECT all
            if len(access_rules) > 0:
                last_rule_number = access_rules[len(access_rules) - 1]['name'].lstrip('Rule @')
                url="%s/fw_ipv4_access_rule?before=%s" % (policy_href, last_rule_number)
            else:
                url="%s/fw_ipv4_access_rule" % policy_href
            
            # add rule source and destinations
            ipv4_access_rule['destinations']['dst'] = ["%s" % d_host['href']]
            ipv4_access_rule['sources']['src'] = ["%s" % s_host['href']]

            # add service 
            if args.protocol == 'rdp':
                ipv4_access_rule['services']['service'] = ["%s" % (query_by_name('Remote Desktop', 'tcp_service')['href'])]
            elif args.protocol == 'ssh':
                ipv4_access_rule['services']['service'] = ["%s" % (query_by_name('SSH', 'tcp_service')['href'])]

            # add comment
            ipv4_access_rule['comment'] = "Added by API during build of %s at %s" % (args.source, datetime.datetime.now())
            
            # upload rule
            req = urllib.request.Request(url=url, data=json.dumps(ipv4_access_rule).encode(), headers=HEADERS, method='POST')
            with OPENER.open(req) as http_response:
                if http_response.status == 201:
                    pass
                else:
                    raise RuntimeError('Problem creating new rule in SMC.') 
            
            # upload policy to firewall cluster
            cluster_href = query_by_name(FIREWALL_CLUSTER_NAME,'fw_cluster')['href']

            req = urllib.request.Request(url="%s/upload" % cluster_href, headers=HEADERS, method='POST')
            with OPENER.open(req) as http_response:
                if http_response.status is 202:
                    follower = json.loads(http_response.read())['follower']
                else:
                    raise RuntimeError('Problem uploading new policy in SMC')

            # query policy upload status until its progress has finished         
            in_progress = True
            counter = 0

            while in_progress is True:    
                req = urllib.request.Request(url=follower, headers=HEADERS, method='GET')
                with OPENER.open(req) as http_response:
                    response = json.loads(http_response.read())
                  
                    if http_response.status != 200 or counter > 100:
                        raise RuntimeError('Problem querying policy status in SMC.')
                    else:
                        in_progress = response['in_progress']
                
                counter +=1
                sleep(3)
    
    except Exception as e:
        print("There was problem in creating the new rule in the SMC: %s" % e)
        sys.exit(1)

    # logout of SMC
    try:
        req = urllib.request.Request(url="%s/logout" % SMC_BASE_URI, headers=HEADERS, method='PUT')
        with OPENER.open(req) as http_response:
            pass

    except Exception as e:
        print("Error encountered logging out of the SMC: %s" % e)
        sys.exit(1)

if __name__ == "__main__":
    main()
